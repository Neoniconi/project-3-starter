#include "dns_packet.h"

/*
 * Param: msg - Buffer to store the packet, offset to the entire buffer is 0
 * Param: identifier - identifier generated by the proxy randomly
 * Param: flags - See definition in RFC1035 4.1.1 (QR, Opcode, ..)
 * Param: qd_count - an unsigned 16 bit integer specifying the number of
 *                   entries in the question section.
 * Param: an_count - an unsigned 16 bit integer specifying the number of
 *                   resource records in the answer section.
 *
 * Purpose: To construct the buffer representation of the dns header
 *
 * Return: void
 *
 * Comment: Review DNS headers for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */

void set_dns_headers(char* msg, uint16_t identifier,uint16_t flags, uint16_t qd_count
					, uint16_t an_count)
{
	uint16_t tmp;
	int index = 0;

	tmp = htons(identifier);
	memcpy(msg, &tmp, SIZE_16);
	index += SIZE_16;
	tmp = htons(flags);
	memcpy(msg+index, &tmp, SIZE_16);
	index += SIZE_16;
	tmp = htons(qd_count);
	memcpy(msg+index, &tmp, SIZE_16);
	index += SIZE_16;
	tmp = htons(an_count);
	memcpy(msg+index, &tmp, SIZE_16);
	index += SIZE_16;
	tmp = htons(NS_COUNT_DEFAULT);
	memcpy(msg+index, &tmp, SIZE_16);
	index += SIZE_16;
	tmp = htons(AR_COUNT_DEFAULT);
	memcpy(msg+index, &tmp, SIZE_16);
}


/*
 * Param: domain - a valid domain name e.g. video.cs.cmu.edu 
 *
 * Purpose: To convert the normal domain name to rfc1035 format
 *
 * Return: Domain name with format defined in rfc1035 
 *		   e.g. 5video2cs3cmu3edu0
 *
 * Comment: Review DNS headers for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */
char* str_to_dnsname(char* domain)
{
	char* lastdot = NULL;
	char* thisdot = NULL;
	thisdot = strstr(domain, DOMAIN_SEPERATOR);
	char* dnsname = (char*)calloc(strlen(domain)*2, sizeof(char));
	memset(dnsname, 0, strlen(domain)*2);
	int index = 0;
	while(thisdot!=NULL)
	{
		if(lastdot == NULL)
		{
			dnsname[index] = (thisdot-domain-0);
			memcpy(dnsname+index+1, domain+index, dnsname[index]);
			index+= (int)dnsname[index]+1;
		}
		else
		{
			thisdot = strstr(lastdot+1, DOMAIN_SEPERATOR);
			if(thisdot == NULL)
			{
				if(strlen(lastdot)>1)
				{
					dnsname[index] = strlen(lastdot) - 1;
					memcpy(dnsname+index+1, lastdot+1, dnsname[index]);
				}
				break;
			}
			dnsname[index] = (thisdot - lastdot) - 1;
			memcpy(dnsname+index+1, lastdot+1, dnsname[index]);
			index+=(int)dnsname[index]+1;
		}
		lastdot = thisdot;
	}
	dnsname[strlen(dnsname)] = 0;
	return dnsname;
}

/*
 * Param: name - a valid domain name e.g. video.cs.cmu.edu 
 * Param: q_type - a two octet code which specifies the type of the query.
 * Param: q_class - a two octet code that specifies the class of the query.
 *
 * Purpose: To a query_t structure containing domain name and type and class
 *
 * Return: An initialized query_t structure.
 *
 * Comment: Review DNS Question section format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */


query_t* create_dns_question(char* name, uint16_t q_type, uint16_t q_class)
{
	query_t* q = malloc(sizeof(query_t));
	q->q_name = str_to_dnsname(name);
	q->q_type = q_type;
	q->q_class = q_class;
	return q;

}

/*
 * Param: msg - Buffer to store the packet, 
 *				offset to the first question is HEADER_LEN 
 * Param: query_t - dns question structure
 *
 * Purpose: To construct the buffer representation of a certain dns question
 *
 * Return: void
 *
 * Comment: Review DNS Question section format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */

void set_dns_question(char* msg, query_t* query)
{
	uint16_t tmp;
	int index = 0;
	memcpy(msg, query->q_name, strlen(query->q_name)+1);
	index+= strlen(query->q_name)+1;
	tmp = htons(query->q_type);
	memcpy(msg+index, &tmp, SIZE_16);
	index+=SIZE_16;
	tmp = htons(query->q_class);
	memcpy(msg+index, &tmp, SIZE_16);
}

/*
 * Param: name - a valid domain name e.g. video.cs.cmu.edu 
 * Param: a_type - a two octet code which specifies the type of the answer.
 * Param: a_class - a two octet code that specifies the class of the answer.
 * Param: ttl - a 32 bit unsigned integer that specifies the time
 *              interval (in seconds) that the resource record may be
 *              cached before it should be discarded
 * Param: length -  an unsigned 16 bit integer that specifies the length in
 *                  octets of the RDATA field. 
 * Param: data - a variable length string of octets that describes the
 *               resource. 
 *
 * Purpose: To construct an answer_t structure containing domain name and 
 *			type, class, ttl, data length, data
 *
 * Return: An initialized answer_t structure.
 *
 * Comment: Review DNS Resource record format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */


answer_t* create_dns_answer(char* name, uint16_t a_type, uint16_t a_class, 
				uint32_t ttl, uint16_t length, char* data)
{
	answer_t* a = malloc(sizeof(answer_t));
	//Here we use Message compression the Default_RR_name is 0xC00C
	uint16_t rr_name = DEFAULT_RR_NAME;
	a->name = malloc(SIZE_16);
	memcpy(a->name, &rr_name, SIZE_16);
	a->type = a_type;
	a->class_name = a_class;
	a->ttl = ttl;
	a->rdlength = length;
	a->rdata = malloc(length);
	memcpy(a->rdata, data, length);
	return a;

}

/*
 * Param: msg - Buffer to store the answer section
 * Param: query_t - dns answer structure (rfc1035 Resource record format)
 *
 * Purpose: To construct the buffer representation of a certain dns answer
 *
 * Return: void
 *
 * Comment: Review DNS Resource record format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */
void set_dns_answer(char* msg, answer_t* answer)
{
	uint16_t tmp;
	uint32_t tmp32;
	int index = 0;
	memcpy(&tmp, answer->name, SIZE_16);
	tmp = htons(tmp);
	memcpy(msg, &tmp, SIZE_16);

	index+=SIZE_16;
	tmp = htons(answer->type);
	memcpy(msg+index, &tmp, SIZE_16);
	index+=SIZE_16;
	tmp = htons(answer->class_name);
	memcpy(msg+index, &tmp, SIZE_16);
	index+=SIZE_16;
	tmp32 = htonl(answer->ttl);
	memcpy(msg+index, &tmp32, SIZE_32);
	index+=SIZE_32;
	tmp = htons(answer->rdlength);
	memcpy(msg+index, &tmp, SIZE_16);
	index+=SIZE_16;
	memcpy(msg+index, answer->rdata, answer->rdlength);
}

/*
 * Param: identifier - identifier generated by the proxy randomly
 * Param: qr - A one bit field that specifies whether this message is a
 *               query (0), or a response (1).
 * Param: aa - Set this to 0 in requests, 1 in responses.
 * Param: qd_count - an unsigned 16 bit integer specifying the number of
 *                   entries in the question section.
 * Param: an_count - an unsigned 16 bit integer specifying the number of
 *                   resource records in the answer section.
 * Param: rcode - Response code - this 4 bit field is set as part of
 *                responses.
 *
 * Purpose: To construct an dns_packet_t structure
 *
 * Return: An initialized dns_packet_t structure
 *
 * Comment: Review DNS protocol format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */

dns_packet_t* create_dns_packet(uint16_t identifier, uint16_t qr
					, uint16_t aa, uint16_t qd_count
					, uint16_t an_count, uint16_t rcode)
{
	dns_packet_t* packet = malloc(sizeof(dns_packet_t));

	packet->header.identifier = identifier;
	packet->header.flags = qr|OPCODE_STANDARD_MASK
				|aa|TC_FALSE_MASK|RD_FALSE_MASK
				|RA_FALSE_MASK|RESERVED_Z_MASK|rcode;
	packet->header.qd_count = qd_count;
	packet->header.an_count = an_count;
	packet->header.ns_count = NS_COUNT_DEFAULT;
	packet->header.ar_count = AR_COUNT_DEFAULT;

	packet->query_list = malloc(qd_count*sizeof(query_t*));
	packet->answer_list = malloc(an_count*sizeof(answer_t*));
	return packet;
}

/*
 * Param: dns_packet_t - dns packet structure
 *
 * Purpose: To construct the buffer representation of a dns packet
 *
 * Return: Return a buffer that contains the information of the 
 *.        packet
 *
 * Comment: Review DNS protocol format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */

char* create_dns_packet_buf(dns_packet_t* packet)
{
	int i;
	int index = 0;
	int data_len = get_pkt_len(packet);
	char* msg = malloc(data_len*sizeof(char));
	set_dns_headers(msg, packet->header.identifier, packet->header.flags
		, packet->header.qd_count, packet->header.an_count);

	index += HEADER_LEN;
	for(i=0;i<packet->header.qd_count;i++)
	{
		set_dns_question(msg+index, packet->query_list[i]);
		index += strlen(packet->query_list[i]->q_name)+1 + 2*SIZE_16;
	}
	for(i=0;i<packet->header.an_count;i++)
	{
		set_dns_answer(msg+index, packet->answer_list[i]);
		index += strlen(packet->answer_list[i]->name) + 3*SIZE_16 + SIZE_32
		+ packet->answer_list[i]->rdlength;
	}
	return msg;
}

void add_dns_question(dns_packet_t* packet, char* name
					, uint16_t q_type, uint16_t q_class, uint16_t index)
{
	if(index < packet->header.qd_count)
		packet->query_list[index] = create_dns_question(name, q_type, q_class);
}

void add_dns_answer(dns_packet_t* packet, char* name, uint16_t a_type, uint16_t a_class, 
				uint32_t ttl,uint16_t length, char* data,  uint16_t index)
{
	if(index < packet->header.an_count)
		packet->answer_list[index] = create_dns_answer(name, a_type, a_class, ttl, length, data);
}

/*
 * Param: query_t - dns_packet_t - dns packet structure
 *
 * Purpose: To get the length of the packet by add the length 
 *          of each section of the packet
 *
 * Return: The length of the packet
 *
 * Comment: Review DNS protocol format for more information.
 *  https://tools.ietf.org/html/rfc1035
 *
 */

int get_pkt_len(dns_packet_t* packet)
{
	int data_len = 0;
	int i;
	int index = 0;
	for(i=0;i<packet->header.qd_count;i++)
	{
		data_len += strlen(packet->query_list[i]->q_name)+1+2*SIZE_16;
	}
	for(i=0;i<packet->header.an_count;i++)
	{ 
		data_len += SIZE_16 + 3*SIZE_16 + SIZE_32
		+ packet->answer_list[i]->rdlength;
	}
	data_len += HEADER_LEN;
	return data_len;

}


/*
 * Param: msg - buffer representation of a dns packet
 *
 * Purpose: To get the qdcount sent by the packet.
 *
 * Return: The qdcount of the packet
 *
 */

uint16_t get_qdcount(char* msg)
{
	int offset = 4;
	uint16_t var;
	memcpy(&var, msg+offset, SIZE_16);
	return ntohs(var);
}

/*
 * Param: msg - buffer representation of a dns packet
 *
 * Purpose: To get the ancount sent by the packet.
 *
 * Return: The ancount of the packet
 *
 */
uint16_t get_ancount(char* msg)
{
	int offset = 6;
	uint16_t var;
	memcpy(&var, msg+offset, SIZE_16);
	return ntohs(var);
}


/*
 * Param: msg - buffer representation of a dns packet
 *
 * Purpose: To get the qrcode sent by the packet. 
 *          0 for query 1 for response
 *
 * Return: The qrcode of the packet
 *
 */
uint16_t get_qrcode(char* msg)
{
	int offset = 2;
	uint16_t var;
	memcpy(&var, msg+offset, SIZE_16);
	uint16_t flag = ntohs(var);
	return (RESPONSE_MASK & flag)!=0;

}

/*
 * Param: msg - buffer representation of a dns packet
 *
 * Purpose: To get the identifier by the packet. 
 *
 * Return: The identifier of the packet
 *
 */
uint16_t get_identifier(char* msg)
{
	int offset = 0;
	uint16_t var;
	memcpy(&var, msg, SIZE_16);
	return ntohs(var);
}

/*
 * Param: msg - buffer representation of a dns packet
 *        index - index number of the question
 *
 * Purpose: To get the domain name of a certain question 
 *
 * Return: The domain name of a certain question
 *
 */

char* get_domain(char* msg, uint16_t index)
{
	uint16_t qdcount = get_qdcount(msg);
	int current = 0;
	int offset = HEADER_LEN;
	char* domain = malloc(MAX_DOMAIN_LEN);
	int domain_offset = 0;
	if(index<qdcount)
	{
		while(current<=index)
		{
			while(msg[offset]!=0)
			{
				if(current == index)
				{
					memcpy(domain+domain_offset, msg+offset+1, (int)msg[offset]);
					domain_offset += msg[offset];
					memcpy(domain+domain_offset, ".", 1);
					domain_offset += 1;
				}
				offset += msg[offset]+1;

			}
			current++;
			offset += 4;
		}

	}
	domain[strlen(domain)-1] = '\0';
	return domain;

}

uint16_t get_answer_offset(char* msg)
{
	uint16_t qdcount = get_qdcount(msg);
	int offset = HEADER_LEN;
	int current = 0;
	while(current < qdcount)
	{
		while(msg[offset]!=0)
		{
			offset += msg[offset]+1;

		}
		current++;
		offset++;
		offset += 4;
	}
	return offset;
}

/*
 * Param: msg - buffer representation of a dns packet
 *        index - index number of the answer
 *
 * Purpose: To get the ip address of a certain answer 
 *
 * Return: The ip address of a certain answer
 *
 */

char* get_ip(char* msg, int index)
{

	int offset = get_answer_offset(msg);
	int ancount = get_ancount(msg);
	char* ip = malloc(4);
	int current = 0;
	if(index<ancount)
	{
		while(current<=index)
		{
			offset += SIZE_16;
			offset += 3*SIZE_16;
			offset += SIZE_32;
			if(current == index)
			{
				memcpy(ip, msg+offset, 4);
				break;
			}
			offset += 4;
			current++;
		}


	}
	return ip;
}


void free_packet(dns_packet_t* packet)
{

}



